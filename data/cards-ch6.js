window.CARDS_CH6 = [
    {
        id: "ch6-0001",
        chapter: 6,
        term: "スプーリング",
        definition: "CPUと低速な入出力装置の間で、高速な補助記憶装置をバッファとして介在させる技術。",
        extraExplain: "ポイント: CPUを入出力待ちから解放し、他の処理を進められるようにします。\nひっかけ: 「主記憶」ではなく「補助記憶（磁気ディスク等）」を利用する点がポイントです。\n例: プリンタへの印刷。パソコンはデータをディスクに送るだけで、実際の印刷完了を待たずに次の作業ができます。\n暗記：低速デバイスとの仲介・CPUの効率化"
    },
    {
        id: "ch6-0002",
        chapter: 6,
        term: "バッファ",
        definition: "処理速度や転送速度の異なる装置間の差を吸収するための一時的な記憶領域。",
        extraExplain: "ポイント: データを小出しにするのではなく、ある程度まとめて送ることで効率を高めます。\n例: YouTubeなどの動画再生。通信が途切れても再生が止まらないよう、先のデータを少し貯めておく場所。\n暗記：速度差のクッション"
    },
    {
        id: "ch6-0003",
        chapter: 6,
        term: "ジョブとタスク",
        definition: "利用者が依頼する仕事の単位が「ジョブ」、OSが管理する実行単位が「タスク（プロセス）」。",
        extraExplain: "ポイント: 1つのジョブ（例：コンパイルして実行）は、複数のタスクに分割されて実行されます。\nひっかけ: 「利用者が意識するのはタスク」という選択肢は×。利用者はジョブ、OSはタスクを意識します。\n暗記：ジョブ＝人間、タスク＝OS"
    },
    {
        id: "ch6-0004",
        chapter: 6,
        term: "タスクの状態遷移",
        definition: "実行可能状態（Ready）、実行状態（Running）、待ち状態（Waiting）の3つのサイクル。",
        extraExplain: "ポイント: 実行状態から待ち状態（入出力待ち）へ、待ち状態から実行可能状態（入出力完了）へと遷移します。\nひっかけ: 待ち状態から「直接」実行状態に戻ることはありません。必ず実行可能状態（列に並ぶ）を経てからです。\n暗記：Ready → Running → Waiting → Ready"
    },
    {
        id: "ch6-0005",
        chapter: 6,
        term: "ディスパッチ",
        definition: "実行可能状態にあるタスクの中から、次に実行するものを選択してCPUの使用権を割り当てること。",
        extraExplain: "ポイント: これを行うOSのモジュールを「ディスパッチャ」と呼びます。\n暗記：タスクへのCPU割り当て"
    },
    {
        id: "ch6-0006",
        chapter: 6,
        term: "プリエンプティブ方式",
        definition: "OSがCPUの使用権を強制的に管理し、タスクを切り替える方式。",
        extraExplain: "ポイント: 現在のOS（Windows, macOS等）の主流。1つのタスクが暴走しても、OSが強制介入してシステム全体を守れます。\n暗記：OSが主導権・強制的切替"
    },
    {
        id: "ch6-0007",
        chapter: 6,
        term: "ラウンドロビン方式",
        definition: "各タスクに「タイムクォンタム（一定時間）」ずつCPUを順番に割り当てるスケジューリング方式。",
        extraExplain: "ポイント: 優先順位に関係なく、平等に時間を分け合います。タイムクォンタムが短すぎると切替の負荷が増えます。\n例: 3人の生徒が1台のPCを「5分交代」で順繰りに使うルール。\n暗記：時間切れで交代・平等"
    },
    {
        id: "ch6-0008",
        chapter: 6,
        term: "ページング",
        definition: "仮想記憶と実記憶を「ページ」と呼ばれる固定長の単位に分割して管理する方式。",
        extraExplain: "ポイント: 主記憶（メモリ）より大きなプログラムを動かすために、必要なページだけをメモリに載せます。\nひっかけ: 固定長ならページング、可変長ならセグメント方式です。\n暗記：固定長・仮想記憶"
    },
    {
        id: "ch6-0009",
        chapter: 6,
        term: "ページフォールト",
        definition: "アクセスしたページが主記憶上にない場合に発生する割込み信号。",
        extraExplain: "ポイント: これが発生すると、OSは補助記憶（HDD等）から必要なページを主記憶へ読み込みます。\n暗記：メモリに無い！という合図"
    },
    {
        id: "ch6-0010",
        chapter: 6,
        term: "LRU（Least Recently Used）",
        definition: "「最後に参照されてから最も時間が経過したページ」を追い出すアルゴリズム。",
        extraExplain: "ポイント: 最も一般的で効率が良いと考えられています。最近使っていないものは、今後も使わないだろうという予測に基づきます。\n例: 本棚がいっぱいになったとき、一番長い間読んでいない本を処分する。\n暗記：最後に使ったのが一番古いものをポイ"
    },
    {
        id: "ch6-0011",
        chapter: 6,
        term: "スラッシング",
        definition: "主記憶不足によりページ置換が頻発し、CPUの処理よりも入出力に時間がかかって性能が激減する現象。",
        extraExplain: "ポイント: ページイン・ページアウトが止まらなくなり、システムが「あっぷあっぷ」している状態です。\n対策: メモリを増設するのが最も有効な解決策です。\n暗記：メモリ不足・動作ガタガタ"
    },
    {
        id: "ch6-0012",
        chapter: 6,
        term: "絶対パスと相対パス",
        definition: "ルート（最上位）からの経路が絶対パス、現在地（カレント）からの経路が相対パス。",
        extraExplain: "ひっかけ: 相対パスでは「.」がカレント、「..」が1つ上のディレクトリを指します。\n例: 「C:\\Users\\Admin」は絶対。「..\\Desktop」は今の場所の1つ上にあるDesktop。\n暗記：ルートからか、今からか"
    },
    {
        id: "ch6-0013",
        chapter: 6,
        term: "フル・差分・増分バックアップ",
        definition: "フルは全データ、差分はフル以降の変更分、増分は前回のバックアップ以降の変更分。",
        extraExplain: "ポイント: 復旧（リストア）は、フル＋最新の差分1つで済む「差分」が速いです。バックアップ時間は「増分」が最短です。\n暗記：差分はフルとの比較、増分は前回との比較"
    },
    {
        id: "ch6-0014",
        chapter: 6,
        term: "コンパイラとインタプリタ",
        definition: "一括翻訳して実行するのがコンパイラ、1行ずつ解釈して実行するのがインタプリタ。",
        extraExplain: "ポイント: コンパイラ（C, Java等）は実行が速いが、デバッグに時間がかかる。インタプリタ（Python, Ruby等）はその逆です。\n暗記：一括（コンパイラ）vs 逐次（インタプリタ）"
    },
    {
        id: "ch6-0015",
        chapter: 6,
        term: "コピーレフト",
        definition: "著作権を保持したまま、利用・改変・再配布を許可し、派生物にも同じ条件を課す考え方。",
        extraExplain: "ポイント: OSS（オープンソース）のライセンス（GPLなど）でよく使われます。\n暗記：自由の連鎖・派生物も自由に"
    },
    {
        id: "ch6-0016",
        chapter: 6,
        term: "ルートディレクトリ",
        definition: "階層型ファイルシステムの最上位にあるディレクトリ。",
        extraExplain: "ポイント: すべてのディレクトリやファイルの起点となります。UNIX系では「/」、Windowsでは「C:\\」などがこれに当たります。\nひっかけ: 「どのディレクトリからでも直接参照できる」のは絶対パスの性質であり、ルートディレクトリ自体の定義ではありません。\n例: 木の「根」にあたる部分。ここから枝（サブディレクトリ）が分かれていきます。\n暗記：階層の最上階・起点"
    },
    {
        id: "ch6-0017",
        chapter: 6,
        term: "カレントディレクトリ",
        definition: "現在、ユーザーが作業の対象としているディレクトリ。",
        extraExplain: "ポイント: 「今いる場所」のことです。相対パスを指定する際の基準点になります。\n例: コマンドプロンプトなどで「C:\\Users\\Admin>」と表示されている場合、Adminフォルダがカレントです。\n暗記：現在の作業場所・「.」で表す"
    },
    {
        id: "ch6-0018",
        chapter: 6,
        term: "絶対パス",
        definition: "ルートディレクトリを基点（出発点）として、目的のファイルまでの場所を示す表記。",
        extraExplain: "ポイント: 現在の作業場所に左右されず、常に同じ記述で特定のファイルを指し示すことができます。\nひっかけ: 記述が長くなりがちですが、どこから実行しても確実にファイルに辿り着けるメリットがあります。\n例: 住所を「東京都...」からすべて書くのと同じイメージ。\n暗記：ルートからのフル住所"
    },
    {
        id: "ch6-0019",
        chapter: 6,
        term: "相対パス",
        definition: "カレントディレクトリを基点（出発点）として、目的のファイルまでの場所を示す表記。",
        extraExplain: "ポイント: 「..」は1つ上の階層を、「.」は現在の階層を指します。\nひっかけ: 作業ディレクトリを移動すると、同じ相対パスでも違うファイルを指したり、エラーになったりします。\n例: 「隣の部屋」や「2階上の会議室」といった、今いる場所を基準にした道案内。\n暗記：今いる場所からの道順"
    },
    {
        id: "ch6-0020",
        chapter: 6,
        term: "フルバックアップ",
        definition: "バックアップの対象となるすべてのデータを毎回保存する方式。",
        extraExplain: "ポイント: データの復旧（リストア）が最も簡単で速いですが、バックアップ自体に時間がかかり、容量も食います。\n例: 毎日、フォルダの中身を丸ごと別ドライブにコピーすること。\n暗記：全部コピー・復旧は最速"
    },
    {
        id: "ch6-0021",
        chapter: 6,
        term: "差分バックアップ",
        definition: "直近のフルバックアップ以降に「変更・追加」されたすべてのデータを保存する方式。",
        extraExplain: "ポイント: 復旧時は「フル ＋ 最新の差分1つ」だけで済みます。日を追うごとにバックアップデータ量は増えていきます。\nひっかけ: 増分（前回との比較）と混同しやすいので注意。基準は常に「最後のフル」です。\n暗記：フルからの変更分すべて"
    },
    {
        id: "ch6-0022",
        chapter: 6,
        term: "増分バックアップ",
        definition: "「前回のバックアップ（フル、増分問わず）」以降に変更された分だけを保存する方式。",
        extraExplain: "ポイント: バックアップ時間が最短で、容量も最小限で済みます。\nひっかけ: 復旧（リストア）する際、フル＋それ以降のすべての増分ファイルを順番に重ねる必要があり、手間と時間がかかります。\n暗記：前回からの変更分のみ・復旧に手間"
    },
    {
        id: "ch6-0023",
        chapter: 6,
        term: "ソースコード",
        definition: "人間が読み書きしやすいプログラミング言語で記述されたプログラムの設計図。",
        extraExplain: "ポイント: このままではコンピュータは実行できないため、翻訳（コンパイル等）が必要です。\n例: C言語やJava、Pythonなどで書かれたテキストファイル。\n暗記：人間が書いたプログラム"
    },
    {
        id: "ch6-0024",
        chapter: 6,
        term: "オブジェクトコード",
        definition: "ソースコードをコンパイラによって機械語（0と1の羅列）に翻訳したデータ。",
        extraExplain: "ポイント: 人間には読めませんが、コンピュータが直接解釈できる形式です。\nひっかけ: これ単体ではまだ「実行ファイル」ではない（リンクが必要）な点に注意。\n暗記：機械語への翻訳結果"
    },
    {
        id: "ch6-0025",
        chapter: 6,
        term: "コンパイラ",
        definition: "ソースコードをまとめて一括でオブジェクトコードへ翻訳・変換するプログラム。",
        extraExplain: "ポイント: 実行前にエラーをチェックできるため、実行速度が速くなります。\n例: C, C++, Java（厳密には中間コードへの変換）など。\n暗記：一括翻訳機"
    },
    {
        id: "ch6-0026",
        chapter: 6,
        term: "コンパイラの処理工程",
        definition: "字句解析 → 構文解析 → 意味解析 → 最適化 → コード生成の順で行われる工程。",
        extraExplain: "ポイント: 「構文解析」で文法的な誤りがないかを調べます。\nひっかけ: 工程の順番を入れ替えて出題されることがあります。「字・構・意・最・生」と覚えましょう。\n暗記：字句・構文・意味・最適化・生成"
    },
    {
        id: "ch6-0027",
        chapter: 6,
        term: "コンパイラ最適化",
        definition: "プログラムの動作を変えずに、実行速度向上やサイズ削減のためにコードを書き換えること。",
        extraExplain: "ポイント: 無駄なループの削除や、計算式の簡略化を自動で行います。\nひっかけ: 「バグを修正する」のではなく、あくまで「効率化」が目的です。\n暗記：中身は同じ、より効率的に"
    },
    {
        id: "ch6-0028",
        chapter: 6,
        term: "リンカ",
        definition: "複数のオブジェクトコードやライブラリを結合し、1つの実行可能なプログラム（ロードモジュール）を作るツール。",
        extraExplain: "ポイント: 翻訳（コンパイル）しただけではバラバラの部品を、1つの製品に組み立てるイメージです。\n暗記：バラバラの部品を連結"
    },
    {
        id: "ch6-0029",
        chapter: 6,
        term: "ロードモジュール",
        definition: "リンク工程を経て完成した、そのまま実行可能な形式のファイル。",
        extraExplain: "ポイント: 補助記憶装置から主記憶（メモリ）にロード（読み込み）して実行されます。\n例: Windowsにおける「.exe」ファイルなど。\n暗記：実行可能ファイル"
    },
    {
        id: "ch6-0030",
        chapter: 6,
        term: "インタプリタ",
        definition: "プログラムを1行ずつ解釈しながら、即座に実行していく方式。",
        extraExplain: "ポイント: 事前のコンパイルが不要なので、修正してすぐに動かせるメリットがあります。\nひっかけ: 実行のたびに翻訳するため、コンパイラ方式に比べて動作速度は遅くなります。\n例: Python, Ruby, JavaScriptなど。\n暗記：逐次翻訳・即実行"
    },
    {
        id: "ch6-0031",
        chapter: 6,
        term: "静的解析ツール",
        definition: "プログラムを実行せずに、ソースコードを解析してバグや脆弱性を検出するツール。",
        extraExplain: "ポイント: 文法ミスやセキュリティ上の弱点を、動かす前に見つけることができます。\nひっかけ: 実際に動かしてテストするツールは「動的テストツール」と呼ばれます。\n暗記：実行せずにバグ探し"
    },
    {
        id: "ch6-0032",
        chapter: 6,
        term: "Eclipse",
        definition: "オープンソース（OSS）で提供されている、多機能な統合開発環境（IDE）。",
        extraExplain: "ポイント: エディタ、コンパイラ、デバッガなどが1つにまとまっています。Java開発で特に有名です。\n暗記：代表的な無料の開発環境"
    },
    {
        id: "ch6-0033",
        chapter: 6,
        term: "コピーレフト",
        definition: "著作権を保持したまま「自由な再配布・改変」を認め、その派生物にも同様の自由を義務付ける考え方。",
        extraExplain: "ポイント: 「自由を独占させない」ための仕組みです。GPL（GNU General Public License）がその代表例です。\nひっかけ: 「著作権を放棄する（パブリックドメイン）」とは全く別物である点に注意してください。\n例: Linuxカーネル。誰でも改良できるが、改良して配布するならそのコードも公開しなければならない。\n暗記：自由の連鎖・派生物もOSS化"
    }
];