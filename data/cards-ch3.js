window.CARDS_CH3 = [
    {
        id: "ch3-0001",
        chapter: 3,
        term: "スタック",
        definition: "最後に格納したデータを最初に取り出す（LIFO：Last-In First-Out）データ構造。",
        extraExplain: "ポイント: 「後入れ先出し」です。データを入れる操作をPush、取り出す操作をPopと呼びます。\nひっかけ: キュー（FIFO）と特徴を入れ替えて出題されるのが定番です。再帰呼び出しの戻り先管理に使われます。\n例: 机に積み上げられた本（一番上に置いた本を、最初に手に取る）。ブラウザの「戻る」ボタンの履歴管理。\n暗記：後入れ先出し・LIFO・Push/Pop"
    },
    {
        id: "ch3-0002",
        chapter: 3,
        term: "キュー",
        definition: "最初に格納したデータを最初に取り出す（FIFO：First-In First-Out）データ構造。",
        extraExplain: "ポイント: 「先入れ先出し」です。データを入れるのをEnqueue、出すのをDequeueと呼びます。\nひっかけ: スタックと異なり、入り口（末尾）と出口（先頭）が分かれています。別名「待ち行列」。\n例: レジの行列（先に並んだ人から会計する）。プリンタへの印刷指示（ジョブ）の待機列。\n暗記：先入れ先出し・FIFO・待ち行列"
    },
    {
        id: "ch3-0003",
        chapter: 3,
        term: "2次元配列の要素参照",
        definition: "行と列の2つの添字を用いてデータにアクセスする構造。一般に 配列[行][列] で指定する。",
        extraExplain: "ポイント: プログラム上では「A[0][2]」のように添字が0から始まる点に注意が必要です。\nひっかけ: 試験問題で「1行目、2列目の要素はどれか」と聞かれた際、開始番号（0か1か）を必ず確認してください。\n例: Excelのセル番地。B3セルは「2列目の3行目」という2つの情報で場所を特定します。\n暗記：行・列の順で指定・添字の開始数に注意"
    },
    {
        id: "ch3-0004",
        chapter: 3,
        term: "配列の特徴",
        definition: "メモリ上の連続した領域にデータを格納し、添字で直接参照できるデータ構造。",
        extraExplain: "ポイント: インデックス（番号）が分かれば、データ量に関わらず一瞬でアクセス（ランダムアクセス）できます。\nひっかけ: 途中にデータを「挿入」したり「削除」したりする場合、後ろにある全データをずらす必要があるため非常に低速です。\n例: 出席番号。番号を言えばすぐ特定の生徒を指名できるが、転校生が割り込むと全員の番号を書き換える手間が出る。\n暗記：参照は爆速・挿入削除は激重"
    },
    {
        id: "ch3-0005",
        chapter: 3,
        term: "リスト（連結リスト）の特徴",
        definition: "データと次の要素へのポインタ（位置情報）をセットにして繋げた構造。",
        extraExplain: "ポイント: メモリ上で離れていても「次はあっち」という鎖で繋がっているため、挿入削除が容易です。\nひっかけ: 特定のn番目を見つけるには、先頭から1つずつ鎖を辿る必要があるため、配列よりアクセスが遅くなります。\n例: 宝探しゲーム。次のヒントが書かれた紙（ポインタ）を順に辿っていくイメージ。\n暗記：挿入削除に強い・特定要素の参照に弱い"
    },
    {
        id: "ch3-0006",
        chapter: 3,
        term: "単方向連結リスト",
        definition: "各要素が「次」の要素へのポインタのみを持つデータ構造。",
        extraExplain: "ポイント: 次の要素へは行けますが、前の要素に戻ることはできません。\nひっかけ: ポインタを保持するためのメモリ領域が、データ本体とは別に必要になります。\n例: 片道切符の電車旅。次の駅には行けるが、戻るための情報（線路）が自分にはない状態。\n暗記：次への一方通行"
    },
    {
        id: "ch3-0007",
        chapter: 3,
        term: "双方向連結リスト",
        definition: "各要素が「前」と「次」の両方のポインタを持つデータ構造。",
        extraExplain: "ポイント: どちらの方向にも自由に辿れるため柔軟です。ただし、ポインタの管理が2倍複雑になります。\nひっかけ: 単方向リストに比べて、ポインタ用のメモリ消費量が増える点がデメリットです。\n例: 数珠つなぎ。隣り合う玉同士が互いに紐で繋がっているイメージ。\n暗記：前後両方のポインタ保持・メモリ消費大"
    },
    {
        id: "ch3-0008",
        chapter: 3,
        term: "環状連結リスト",
        definition: "末尾の要素が先頭の要素を指すように繋がれたリスト構造。",
        extraExplain: "ポイント: 終わりがなく、一周して元の場所に戻れるのが特徴です。\nひっかけ: 単方向か双方向かに関わらず、ループ構造になっていれば環状リストです。\n例: 山手線。最後の駅から次の駅へ進むと、最初の駅に戻ってくるイメージ。\n暗記：最後が最初を指す・ループ構造"
    },
    {
        id: "ch3-0009",
        chapter: 3,
        term: "木構造（ツリー構造）",
        definition: "1つの根（ルート）から節（ノード）が枝分かれしていく階層的なデータ構造。",
        extraExplain: "ポイント: 親ノード1つに対し、複数の子ノードを持つことができます。最下層を「葉（リーフ）」と呼びます。\nひっかけ: 閉路（ぐるっと一周する道）を持たないのがグラフ構造との違いです。\n例: PCのフォルダ構造。Cドライブ（根）の中に複数のフォルダ（節）があり、その中にファイル（葉）がある。\n暗記：階層構造・親子関係・根/節/葉"
    },
    {
        id: "ch3-0010",
        chapter: 3,
        term: "2分木",
        definition: "各ノードが持つ子の数が、最大で2つまでの木構造。",
        extraExplain: "ポイント: 左の子と右の子を明確に区別します。探索や整列に広く応用されます。\nひっかけ: 「必ず2つある」のではなく「最大2つ（0か1か2）」である点に注意。\n例: 家系図を「父方」と「母方」の2系統だけで整理したもの。\n暗記：枝分かれは2つまで"
    },
    {
        id: "ch3-0011",
        chapter: 3,
        term: "完全2分木",
        definition: "根から葉までの深さがほぼ一定で、左から順に詰まったバランスの良い2分木。",
        extraExplain: "ポイント: 木の高さが最小限に抑えられているため、探索効率が非常に良いです。\nひっかけ: 右側だけ枝が長いような「偏った木」は完全2分木とは呼びません。\n例: トーナメント表。シード枠が少なく、全体が均等に埋まっている状態。\n暗記：隙間なく詰まった2分木・バランス型"
    },
    {
        id: "ch3-0012",
        chapter: 3,
        term: "ハッシュ表（ハッシュ法）",
        definition: "データの値から計算した「ハッシュ値」を格納場所（アドレス）とする探索手法。",
        extraExplain: "ポイント: データ量が増えても、計算一回で場所を特定できるため、探索速度が極めて高速です。\nひっかけ: 「2分探索法（ソート済みが必要）」と違い、データの並び順は関係ありません。\n例: 下駄箱。自分の名札の番号（ハッシュ値）と同じ番号の棚に行けば、すぐ靴が見つかるイメージ。\n暗記：計算で場所を特定・最速の探索"
    },
    {
        id: "ch3-0013",
        chapter: 3,
        term: "衝突（コリジョン）",
        definition: "ハッシュ法において、異なるデータから同じハッシュ値（アドレス）が算出されてしまうこと。",
        extraExplain: "ポイント: ハッシュ関数の設計が悪いと頻発します。解決法として「オープンアドレス法」などがあります。\n例: 誕生日の下2桁をハッシュ値にしたとき、1月15日生まれと2月15日生まれが同じ場所を奪い合う状態。\n暗記：アドレスの被り・解決策が必要"
    },
    {
        id: "ch3-0014",
        chapter: 3,
        term: "ヒープ",
        definition: "親のデータが子より常に大きい（または小さい）というルールを持つ完全2分木。",
        extraExplain: "ポイント: 根（一番上）に常に最大値（または最小値）が来ます。優先度付きキューの実装に使われます。\nひっかけ: 左右の子同士に大小のルールはありません（左が右より大きくても良い）。\n例: ヒープソート。一番大きな数字を次々と取り出して並べる整列アルゴリズムの基礎。\n暗記：親子間の大小ルール・最大最小の取り出しに特化"
    }
];