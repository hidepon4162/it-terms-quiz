window.CARDS_CH3 = [
    {
        id: "ch3-0001", chapter: 3, term: "スタック",
        definition: "最後に格納したデータを最初に取り出す（LIFO：Last-In First-Out）データ構造。",
        extraExplain: "ポイント: 「後入れ先出し」。Push（挿入）とPop（取出）の用語もセットで覚えましょう。\nひっかけ: 「先に入れたものが先に出る」はキューの説明なので混同注意。\n例: ブラウザの「戻る」ボタン（最新の閲覧履歴から順に戻る）、机に積んだ本。\n暗記：後入れ先出し・LIFO"
    },
    {
        id: "ch3-0002", chapter: 3, term: "キュー",
        definition: "最初に格納したデータを最初に取り出す（FIFO：First-In First-Out）データ構造。",
        extraExplain: "ポイント: 「先入れ先出し」。Enqueue（待ち行列へ入れる）とDequeue（取り出す）を使います。\nひっかけ: スタック（LIFO）との逆転現象に注意。\n例: レジの待ち行列、プリンタへの印字待ちデータ（ジョブキュー）。\n暗記：先入れ先出し・FIFO"
    },
    {
        id: "ch3-0003", chapter: 3, term: "2次元配列の要素参照",
        definition: "行と列の2つの添字を用いてデータにアクセスする構造。配列名[行][列]などで表す。",
        extraExplain: "ポイント: プログラミング言語によって「0」から始まるか「1」から始まるか注意が必要です。\n例: Excelのシートのように、A行3列目のデータを「A[0][2]」のように指定するイメージ。\n暗記：行と列の添字"
    },
    {
        id: "ch3-0004", chapter: 3, term: "配列の特徴",
        definition: "連続したメモリ領域にデータを格納し、添字（インデックス）で直接参照できる構造。",
        extraExplain: "ポイント: ランダムアクセスが可能で、データの参照・更新は非常に高速。\nひっかけ: データの「挿入」や「削除」は、以降の要素をずらす必要があるため低速です。\n例: クラスの出席番号。番号さえ分かればすぐ本人を特定できる。\n暗記：参照は速い・挿入は遅い"
    },
    {
        id: "ch3-0005", chapter: 3, term: "連結リスト（ポインタ型）",
        definition: "データ部と次の要素へのポインタ（位置情報）をセットにしてつなげた構造。",
        extraExplain: "ポイント: メモリ上でバラバラに配置されていても、ポインタで芋づる式に辿れます。\n例: 要素の削除時、前後のポインタをつなぎ変えるだけで済むため、配列より高速。\n暗記：つなぎ変えに強い"
    },
    {
        id: "ch3-0006", chapter: 3, term: "線形探索法（リニアサーチ）",
        definition: "先頭から順番に、目的のデータが見つかるまで調べる最も単純な探索法。",
        extraExplain: "ポイント: データの並び順（昇順・降順）に関わらず実行可能です。\n例: バラバラに置かれたカードの中から、特定の数字を探す方法。\n暗記：端から順番に"
    },
    {
        id: "ch3-0007", chapter: 3, term: "2分探索法（バイナリサーチ）",
        definition: "整列済みのデータを対象に、探索範囲を半分に絞り込みながら探す手法。",
        extraExplain: "ポイント: 1回の比較で候補が半分になるため、データ量が多くても非常に高速。\nひっかけ: 「データがソート（整列）されていること」が必須条件。されていないと使えません。\n例: 辞書で「さ」行を探すとき、真ん中あたりを開いて前後を判断する。\n暗記：整列済みが条件・半分ずつ"
    },
    {
        id: "ch3-0008", chapter: 3, term: "ハッシュ探索法",
        definition: "ハッシュ関数を用いて、データの格納場所を計算によって一意に特定する手法。",
        extraExplain: "ポイント: データ量が増えても、ほぼ一定の「計算時間」で見つけ出せます。\n例: 100人の会員情報を、会員番号の末尾1桁（ハッシュ値）で部屋分けして管理する。\n暗記：計算で一発特定"
    },
    {
        id: "ch3-0009", chapter: 3, term: "選択ソート",
        definition: "未整列のデータから最小値（または最大値）を見つけ、先頭と入れ替える操作を繰り返す手法。",
        extraExplain: "ポイント: 常に「最小値」を探して端に固めていくイメージです。\n暗記：最小を選んで移動"
    },
    {
        id: "ch3-0010", chapter: 3, term: "バブルソート（基本交換法）",
        definition: "隣り合う要素を比較し、順序が逆なら入れ替える操作を繰り返す手法。",
        extraExplain: "ポイント: 軽い泡（最小値）が上に上がってくるように、端から順に確定していきます。\n暗記：隣同士を比較交換"
    },
    {
        id: "ch3-0011", chapter: 3, term: "クイックソート",
        definition: "基準値（ピボット）を決め、それより大きいか小さいかで分割を繰り返す高速なソート。",
        extraExplain: "ポイント: 分割統治法を利用した、平均的に最も高速とされるソート法の一つです。\n暗記：基準値でグループ分け"
    },
    {
        id: "ch3-0012", chapter: 3, term: "アルゴリズムの計算量",
        definition: "データ量nに対して、処理時間やメモリ使用量がどの程度増えるかを示す指標。O(n)などで表す。",
        extraExplain: "ポイント: 2分探索はO(log n)、線形探索はO(n)となり、logの方が効率が良いです。\n暗記：オーダー(O)"
    }
];